/**
 * Generates a typed map of direct-child files under `public/`, grouped by their direct parent folder.
 *
 * Output shape:
 *   export const PUBLIC_ASSETS = {
 *     "/": ["/favicon.ico"],
 *     "/audio": ["/audio/foo.ogg"],
 *     "/image": ["/image/bar.avif"],
 *   } as const;
 *
 * Notes:
 * - Keys are `"/"` for root-level files in `public/`, otherwise `"/<subfolder>"` for direct subfolders.
 * - Values include ONLY direct child files of that folder (no recursion).
 * - Value items are paths relative to `public/`, always starting with `/`.
 */

import type { Dirent } from "node:fs";
import { mkdir, readdir, writeFile } from "node:fs/promises";
import * as path from "node:path";
import { fileURLToPath } from "node:url";

type PublicAssetsMap = Record<string, readonly string[]>;

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// `scripts/` lives at repo root; `public/` is sibling.
const PROJECT_ROOT = path.resolve(__dirname, "..");
const PUBLIC_DIR = path.join(PROJECT_ROOT, "public");
const GENERATED_DIR = path.join(PROJECT_ROOT, "src", "generated");
const OUTPUT_FILE = path.join(GENERATED_DIR, "public-assets.ts");

function assertSafePublicRelative(rel: string): void {
	// We only ever want leading-slash, POSIX-style asset paths like `/foo.png` or `/bar/baz.jpg`
	// but values in this generator are limited to direct children so at most one `/` after leading slash.
	if (!rel.startsWith("/"))
		throw new Error(`Expected asset path to start with "/": ${rel}`);
	if (rel.includes("\\"))
		throw new Error(`Backslashes are not allowed in asset paths: ${rel}`);
	if (rel.includes(".."))
		throw new Error(`Path traversal is not allowed in asset paths: ${rel}`);
}

function toPosix(p: string): string {
	return p.split(path.sep).join("/");
}

function jsonStringifyAsConst(obj: unknown): string {
	// We want stable, readable output; JSON.stringify is fine since keys/values are strings and arrays.
	return JSON.stringify(obj, null, 2);
}

async function listDirectFiles(dirAbs: string): Promise<string[]> {
	const entries = (await readdir(dirAbs, { withFileTypes: true })) as Dirent[];

	// Only direct files
	const files = entries
		.filter((e: Dirent) => e.isFile())
		.map((e: Dirent) => e.name)
		.sort((a: string, b: string) => a.localeCompare(b));

	return files;
}

async function generate(): Promise<{ map: PublicAssetsMap; emitted: string }> {
	// Root-level files: `public/*` where entry is a file
	const rootFiles = await listDirectFiles(PUBLIC_DIR);
	const map: Record<string, string[]> = {};

	map["/"] = rootFiles
		.map((name) => `/${toPosix(name)}`)
		.map((p) => {
			assertSafePublicRelative(p);
			return p;
		});

	// Direct subfolders of `public/`
	const publicEntries = (await readdir(PUBLIC_DIR, {
		withFileTypes: true,
	})) as Dirent[];
	const subdirs = publicEntries
		.filter((e: Dirent) => e.isDirectory())
		.map((e: Dirent) => e.name)
		.sort((a: string, b: string) => a.localeCompare(b));

	for (const subdirName of subdirs) {
		const subdirAbs = path.join(PUBLIC_DIR, subdirName);
		const files = await listDirectFiles(subdirAbs);

		const key = `/${toPosix(subdirName)}`;
		const values = files
			.map((file) => `/${toPosix(path.posix.join(subdirName, file))}`)
			.map((p) => {
				assertSafePublicRelative(p);
				return p;
			});

		map[key] = values;
	}

	// Ensure deterministic key order: "/" first, then alphabetical
	const ordered: Record<string, string[]> = {};
	ordered["/"] = map["/"] ?? [];

	for (const k of Object.keys(map)
		.filter((k) => k !== "/")
		.sort((a, b) => a.localeCompare(b))) {
		ordered[k] = map[k] ?? [];
	}

	const banner = `/* eslint-disable */
// This file is auto-generated by \`scripts/generate-public-assets.ts\`.
// Do not edit manually.
`;

	const emitted = `${banner}
export const PUBLIC_ASSETS = ${jsonStringifyAsConst(ordered)} as const;

export type PublicAssets = typeof PUBLIC_ASSETS;
export type PublicAssetFolder = keyof PublicAssets;
export type PublicAssetPath = PublicAssets[PublicAssetFolder][number];
`;

	return { emitted, map: ordered };
}

async function main(): Promise<void> {
	const { emitted } = await generate();

	await mkdir(GENERATED_DIR, { recursive: true });
	await writeFile(OUTPUT_FILE, emitted, "utf8");

	// Log the command-friendly path from project root
	const rel = path.relative(PROJECT_ROOT, OUTPUT_FILE);
	// biome-ignore lint/suspicious/noConsole: this is a build-time generator script
	console.log(`Generated: ${toPosix(rel)}`);
}

await main();
